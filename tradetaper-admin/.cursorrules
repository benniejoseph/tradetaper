# TradeTaper Admin Dashboard - Cursor Rules

You are an expert React/Next.js developer working on TradeTaper's admin dashboard, a comprehensive analytics and management interface.

## Tech Stack
- **Framework**: Next.js 15 with App Router
- **Language**: TypeScript
- **Styling**: Tailwind CSS v4
- **State Management**: TanStack Query (React Query)
- **Charts**: Recharts for data visualization
- **UI Components**: Headless UI, Framer Motion
- **Maps**: React Leaflet for geographic data
- **Virtual Scrolling**: React Window for large datasets

## Admin Dashboard Purpose
This admin interface provides:
- Real-time system analytics and KPIs
- User management and analytics
- Trading data insights and monitoring
- Geographic distribution analysis
- Revenue and subscription tracking
- System health monitoring

## Architecture Patterns

### App Router Structure
- Use Next.js 15 App Router for all routing
- Implement proper loading.tsx and error.tsx for each route
- Use layout.tsx for shared admin navigation
- Prefer Server Components for static admin data

### Code Organization
```
src/
├── app/                    # Next.js App Router
│   ├── page.tsx           # Main dashboard
│   ├── users/             # User management
│   ├── geographic/        # Geographic analytics
│   ├── revenue/           # Revenue analytics
│   └── layout.tsx         # Admin layout with navigation
├── components/            # Admin-specific components
│   ├── dashboard/         # Dashboard widgets
│   ├── charts/           # Chart components
│   ├── tables/           # Data table components
│   └── ui/               # Base UI components
├── lib/                  # Utilities and API clients
├── hooks/                # Custom React Query hooks
└── types/                # TypeScript definitions
```

## Component Guidelines

### Admin Dashboard Components
- Design for data-heavy interfaces
- Implement proper loading skeletons
- Handle empty states gracefully
- Include error boundaries for each major section

Example Dashboard Card:
```typescript
interface DashboardCardProps {
  title: string;
  value: string | number;
  change?: number;
  icon: React.ComponentType<{ className?: string }>;
  isLoading?: boolean;
}

export function DashboardCard({ title, value, change, icon: Icon, isLoading }: DashboardCardProps) {
  if (isLoading) {
    return <div className="bg-white p-6 rounded-lg shadow animate-pulse">
      <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
      <div className="h-8 bg-gray-200 rounded w-1/2"></div>
    </div>;
  }

  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm font-medium text-gray-600">{title}</p>
          <p className="text-2xl font-bold text-gray-900">{value}</p>
          {change !== undefined && (
            <p className={`text-sm ${change >= 0 ? 'text-green-600' : 'text-red-600'}`}>
              {change >= 0 ? '+' : ''}{change.toFixed(1)}%
            </p>
          )}
        </div>
        <Icon className="h-8 w-8 text-gray-400" />
      </div>
    </div>
  );
}
```

## Data Management with React Query

### Query Organization
- Create custom hooks for each data entity
- Implement proper cache keys and invalidation
- Use optimistic updates for admin actions
- Handle background refetch for real-time data

Example Query Hook:
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

export function useUsers(filters?: UserFilters) {
  return useQuery({
    queryKey: ['users', filters],
    queryFn: () => adminApi.getUsers(filters),
    staleTime: 5 * 60 * 1000, // 5 minutes
    refetchInterval: 30 * 1000, // 30 seconds for admin data
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (data: { id: string; updates: Partial<User> }) => 
      adminApi.updateUser(data.id, data.updates),
    onSuccess: (updatedUser) => {
      // Optimistic update
      queryClient.setQueryData(['users'], (old: User[]) =>
        old?.map(user => user.id === updatedUser.id ? updatedUser : user)
      );
      
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['user-stats'] });
    },
  });
}
```

### Real-time Data Updates
- Use polling for critical admin metrics
- Implement WebSocket connections for live activity feeds
- Show data freshness indicators
- Handle connection failures gracefully

```typescript
export function useRealTimeMetrics() {
  const [isConnected, setIsConnected] = useState(false);
  const queryClient = useQueryClient();

  useEffect(() => {
    const socket = io('/admin', {
      auth: { token: getAdminToken() }
    });

    socket.on('connect', () => setIsConnected(true));
    socket.on('disconnect', () => setIsConnected(false));
    
    socket.on('metrics:update', (data) => {
      queryClient.setQueryData(['dashboard-metrics'], data);
    });

    socket.on('user:activity', (activity) => {
      queryClient.setQueryData(['recent-activity'], (old) => 
        [activity, ...(old || []).slice(0, 49)] // Keep last 50 activities
      );
    });

    return () => socket.disconnect();
  }, [queryClient]);

  return { isConnected };
}
```

## Data Visualization

### Chart Components with Recharts
- Use consistent color schemes across all charts
- Implement responsive chart sizing
- Add proper tooltips and legends
- Handle empty data states

Example Chart Component:
```typescript
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

interface RevenueChartProps {
  data: RevenueData[];
  isLoading?: boolean;
}

export function RevenueChart({ data, isLoading }: RevenueChartProps) {
  if (isLoading) {
    return <div className="h-64 bg-gray-100 animate-pulse rounded" />;
  }

  if (!data || data.length === 0) {
    return (
      <div className="h-64 flex items-center justify-center text-gray-500">
        No revenue data available
      </div>
    );
  }

  return (
    <ResponsiveContainer width="100%" height={256}>
      <LineChart data={data}>
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis 
          dataKey="date" 
          tickFormatter={(date) => new Date(date).toLocaleDateString()}
        />
        <YAxis 
          tickFormatter={(value) => `$${(value / 1000).toFixed(0)}k`}
        />
        <Tooltip 
          labelFormatter={(date) => new Date(date).toLocaleDateString()}
          formatter={(value) => [`$${value.toLocaleString()}`, 'Revenue']}
        />
        <Line 
          type="monotone" 
          dataKey="revenue" 
          stroke="#3b82f6" 
          strokeWidth={2}
          dot={{ fill: '#3b82f6', strokeWidth: 2, r: 4 }}
        />
      </LineChart>
    </ResponsiveContainer>
  );
}
```

### Geographic Data Visualization
- Use React Leaflet for world maps
- Implement proper clustering for dense data
- Add interactive tooltips and popups
- Handle different zoom levels appropriately

```typescript
import { MapContainer, TileLayer, CircleMarker, Popup } from 'react-leaflet';

interface GeographicMapProps {
  userLocations: UserLocationData[];
}

export function GeographicMap({ userLocations }: GeographicMapProps) {
  return (
    <MapContainer 
      center={[20, 0]} 
      zoom={2} 
      className="h-96 w-full rounded-lg"
    >
      <TileLayer
        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        attribution='&copy; OpenStreetMap contributors'
      />
      {userLocations.map((location) => (
        <CircleMarker
          key={`${location.lat}-${location.lng}`}
          center={[location.lat, location.lng]}
          radius={Math.log(location.userCount) * 3}
          fillColor="#3b82f6"
          color="#1e40af"
          weight={1}
          fillOpacity={0.6}
        >
          <Popup>
            <div>
              <h3 className="font-semibold">{location.country}</h3>
              <p>{location.userCount} users</p>
              <p>${location.revenue.toLocaleString()} revenue</p>
            </div>
          </Popup>
        </CircleMarker>
      ))}
    </MapContainer>
  );
}
```

## Data Tables and Large Datasets

### Virtual Scrolling for Performance
- Use React Window for large user lists
- Implement proper row height calculations
- Add search and filtering capabilities
- Maintain selection state correctly

```typescript
import { FixedSizeList as List } from 'react-window';

interface UserTableProps {
  users: User[];
  onUserSelect: (user: User) => void;
  selectedUsers: Set<string>;
}

export function VirtualUserTable({ users, onUserSelect, selectedUsers }: UserTableProps) {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {
    const user = users[index];
    const isSelected = selectedUsers.has(user.id);

    return (
      <div style={style} className={`flex items-center p-2 border-b ${isSelected ? 'bg-blue-50' : ''}`}>
        <input
          type="checkbox"
          checked={isSelected}
          onChange={() => onUserSelect(user)}
          className="mr-3"
        />
        <div className="flex-1 grid grid-cols-4 gap-4">
          <span className="font-medium">{user.name}</span>
          <span className="text-gray-600">{user.email}</span>
          <span className="text-sm">{user.joinDate}</span>
          <span className={`text-sm ${user.isActive ? 'text-green-600' : 'text-gray-400'}`}>
            {user.isActive ? 'Active' : 'Inactive'}
          </span>
        </div>
      </div>
    );
  };

  return (
    <div className="border rounded-lg">
      <div className="bg-gray-50 p-2 grid grid-cols-4 gap-4 font-semibold border-b">
        <span>Name</span>
        <span>Email</span>
        <span>Join Date</span>
        <span>Status</span>
      </div>
      <List
        height={400}
        itemCount={users.length}
        itemSize={60}
        width="100%"
      >
        {Row}
      </List>
    </div>
  );
}
```

## Admin-Specific UI Patterns

### Bulk Actions
- Implement multi-select with keyboard shortcuts
- Provide bulk edit capabilities
- Show progress for bulk operations
- Allow operation cancellation

```typescript
export function useBulkActions<T extends { id: string }>(items: T[]) {
  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set());
  const [isProcessing, setIsProcessing] = useState(false);

  const toggleSelection = (id: string) => {
    setSelectedItems(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  };

  const selectAll = () => {
    setSelectedItems(new Set(items.map(item => item.id)));
  };

  const clearSelection = () => {
    setSelectedItems(new Set());
  };

  const executeBulkAction = async (action: (ids: string[]) => Promise<void>) => {
    if (selectedItems.size === 0) return;
    
    setIsProcessing(true);
    try {
      await action(Array.from(selectedItems));
      clearSelection();
    } finally {
      setIsProcessing(false);
    }
  };

  return {
    selectedItems,
    toggleSelection,
    selectAll,
    clearSelection,
    executeBulkAction,
    isProcessing,
    selectedCount: selectedItems.size
  };
}
```

### Confirmation Modals
- Implement confirmation dialogs for destructive actions
- Show impact of actions (e.g., "This will affect 25 users")
- Provide undo functionality where possible

```typescript
interface ConfirmationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  variant?: 'danger' | 'warning' | 'info';
}

export function ConfirmationModal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  variant = 'info'
}: ConfirmationModalProps) {
  const variantStyles = {
    danger: 'bg-red-600 hover:bg-red-700',
    warning: 'bg-yellow-600 hover:bg-yellow-700',
    info: 'bg-blue-600 hover:bg-blue-700'
  };

  return (
    <Dialog open={isOpen} onClose={onClose} className="relative z-50">
      <div className="fixed inset-0 bg-black/30" aria-hidden="true" />
      <div className="fixed inset-0 flex items-center justify-center p-4">
        <Dialog.Panel className="bg-white rounded-lg p-6 max-w-md mx-auto">
          <Dialog.Title className="text-lg font-semibold mb-2">
            {title}
          </Dialog.Title>
          <p className="text-gray-600 mb-6">{message}</p>
          <div className="flex gap-3 justify-end">
            <button
              onClick={onClose}
              className="px-4 py-2 text-gray-700 bg-gray-200 rounded hover:bg-gray-300"
            >
              {cancelText}
            </button>
            <button
              onClick={onConfirm}
              className={`px-4 py-2 text-white rounded ${variantStyles[variant]}`}
            >
              {confirmText}
            </button>
          </div>
        </Dialog.Panel>
      </div>
    </Dialog>
  );
}
```

## Security and Access Control

### Admin Authentication
- Implement role-based access control
- Use admin-specific JWT tokens
- Add session timeout for security
- Log all admin actions for auditing

```typescript
export function useAdminAuth() {
  const { data: adminUser, isLoading } = useQuery({
    queryKey: ['admin-user'],
    queryFn: () => adminApi.getCurrentAdmin(),
    retry: false,
    staleTime: 5 * 60 * 1000
  });

  const hasPermission = (permission: AdminPermission) => {
    return adminUser?.permissions.includes(permission) || adminUser?.role === 'super_admin';
  };

  const requirePermission = (permission: AdminPermission) => {
    if (!hasPermission(permission)) {
      throw new Error(`Insufficient permissions: ${permission}`);
    }
  };

  return {
    adminUser,
    isLoading,
    isAuthenticated: !!adminUser,
    hasPermission,
    requirePermission
  };
}
```

## Performance Optimization

### Lazy Loading and Code Splitting
- Lazy load heavy admin components
- Implement progressive loading for large datasets
- Use Suspense boundaries appropriately

```typescript
import dynamic from 'next/dynamic';

const GeographicAnalytics = dynamic(() => import('./GeographicAnalytics'), {
  loading: () => <div className="h-96 bg-gray-100 animate-pulse rounded" />,
  ssr: false
});

const UserManagement = dynamic(() => import('./UserManagement'), {
  loading: () => <AdminPageSkeleton />,
});
```

### Data Caching Strategy
- Cache admin queries for 5-10 minutes
- Use background refetch for real-time feel
- Implement selective cache invalidation

```typescript
export const adminQueryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      refetchOnWindowFocus: false,
      refetchInterval: 30 * 1000, // Auto-refresh every 30 seconds
      retry: (failureCount, error) => {
        // Don't retry authentication errors
        if (error.status === 401) return false;
        return failureCount < 3;
      }
    }
  }
});
```

## Admin-Specific Best Practices

### Data Export Functionality
- Implement CSV/Excel export for all major datasets
- Add filtering options before export
- Show export progress for large datasets
- Email large exports instead of direct download

### Activity Logging
- Log all admin actions with timestamps
- Include user context and IP addresses
- Implement audit trail viewing
- Export audit logs for compliance

### Keyboard Shortcuts
- Implement admin-specific keyboard shortcuts
- Add shortcut help modal (? key)
- Support bulk selection with Shift+Click
- Enable quick navigation between sections

## Error Prevention

### Don't:
- Show sensitive user data unnecessarily
- Skip confirmation for destructive actions
- Ignore admin permission checks
- Forget to log admin activities
- Use infinite scroll without virtual scrolling
- Skip loading states for admin queries

### Do:
- Implement proper admin role validation
- Add confirmation modals for all destructive actions
- Use virtual scrolling for large datasets
- Cache admin data appropriately
- Implement proper error boundaries
- Show clear loading and empty states
- Add comprehensive audit logging

## Common Admin Operations

```bash
# Development
npm run dev

# Type checking
npx tsc --noEmit

# Testing admin workflows
npm run test:admin

# Building for production
npm run build
```

When working on this admin dashboard, prioritize data integrity, security, and performance. Always implement proper permission checks and audit logging for all admin actions. Design for scalability with large datasets and real-time updates.