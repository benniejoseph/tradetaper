# TradeTaper Frontend - Cursor Rules

You are an expert React/Next.js frontend developer working on TradeTaper, a professional trading journal platform.

## Tech Stack
- **Framework**: Next.js 15 with App Router
- **Language**: TypeScript
- **Styling**: Tailwind CSS
- **State Management**: Redux Toolkit
- **Charts**: Lightweight Charts (TradingView)
- **Forms**: React Hook Form (when needed)
- **Real-time**: Socket.IO client
- **Payments**: Stripe React components
- **Build**: Next.js with experimental optimizations

## Architecture Patterns

### App Router Structure
- Use Next.js 15 App Router exclusively
- Prefer Server Components when possible
- Use 'use client' directive only when absolutely necessary
- Implement proper loading.tsx and error.tsx boundaries

### Code Organization
```
src/
├── app/                    # Next.js App Router
│   ├── (app)/             # Main authenticated app
│   ├── (auth)/            # Authentication pages
│   ├── layout.tsx         # Root layout
│   └── page.tsx           # Landing page
├── components/            # Reusable UI components
│   ├── ui/               # Base UI components
│   ├── trading/          # Trading-specific components
│   └── forms/            # Form components
├── store/                # Redux Toolkit store
├── hooks/                # Custom React hooks
├── services/             # API service functions
├── utils/                # Utility functions
├── types/                # TypeScript definitions
└── config/               # Configuration files
```

## Component Guidelines

### Functional Components Only
- Use only functional components with hooks
- Define prop interfaces for all components
- Use default parameters instead of defaultProps
- Implement proper TypeScript typing

Example Component:
```typescript
interface TradeCardProps {
  trade: Trade;
  onEdit?: (id: string) => void;
  className?: string;
}

export function TradeCard({ trade, onEdit, className = '' }: TradeCardProps) {
  const formatPrice = useCallback((price: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2
    }).format(price);
  }, []);

  return (
    <div className={`bg-white rounded-lg shadow-md p-4 ${className}`}>
      <div className="flex justify-between items-center">
        <span className={`font-medium ${trade.side === 'BUY' ? 'text-green-600' : 'text-red-600'}`}>
          {trade.side} {trade.symbol}
        </span>
        <span className="text-gray-600">{formatPrice(trade.entryPrice)}</span>
      </div>
    </div>
  );
}
```

### Server vs Client Components
- **Server Components** (default): Data fetching, static content, SEO-critical pages
- **Client Components** ('use client'): Interactive elements, hooks, state management, event handlers

```typescript
// Server Component (default)
export default async function TradePage({ params }: { params: { id: string } }) {
  const trade = await fetchTrade(params.id);
  return <TradeDetails trade={trade} />;
}

// Client Component
'use client';
export function TradeForm({ onSubmit }: { onSubmit: (data: TradeData) => void }) {
  const [formData, setFormData] = useState<TradeData>({});
  // ... interactive form logic
}
```

## State Management

### Redux Toolkit
- Use createSlice for all reducers
- Use createAsyncThunk for API calls
- Implement proper loading and error states
- Use createSelector for derived state

Example Slice:
```typescript
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

export const fetchTrades = createAsyncThunk(
  'trades/fetchTrades',
  async (params: FetchTradesParams, { rejectWithValue }) => {
    try {
      const response = await tradesApi.getTrades(params);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

const tradesSlice = createSlice({
  name: 'trades',
  initialState: {
    items: [],
    loading: false,
    error: null,
    pagination: { page: 1, limit: 20, total: 0 }
  },
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
    updateTrade: (state, action) => {
      const index = state.items.findIndex(trade => trade.id === action.payload.id);
      if (index !== -1) {
        state.items[index] = action.payload;
      }
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTrades.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTrades.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload.trades;
        state.pagination = action.payload.pagination;
      })
      .addCase(fetchTrades.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  }
});
```

### Local State Management
- Use useState for component-local state
- Use useReducer for complex state logic
- Prefer props and composition over global state when possible

## Styling with Tailwind CSS

### Design System
- Use consistent spacing scale (4, 8, 12, 16, 24, 32, 48, 64)
- Implement consistent color palette
- Use semantic color names (primary, secondary, success, danger)
- Follow mobile-first responsive design

### Common Patterns
```typescript
// Color coding for trading
const sideColors = {
  BUY: 'text-green-600 bg-green-50 border-green-200',
  SELL: 'text-red-600 bg-red-50 border-red-200'
};

// Consistent button styles
const buttonVariants = {
  primary: 'bg-blue-600 hover:bg-blue-700 text-white',
  secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-900',
  danger: 'bg-red-600 hover:bg-red-700 text-white'
};
```

### Responsive Design
- Mobile-first approach: base styles for mobile, then `sm:`, `md:`, `lg:`, `xl:`
- Test on actual devices, not just browser DevTools
- Consider touch targets (minimum 44px)

## Trading-Specific Components

### Chart Integration
- Use Lightweight Charts for price/performance visualization
- Implement proper chart cleanup on unmount
- Handle chart resizing responsively

Example Chart Component:
```typescript
'use client';
import { useEffect, useRef } from 'react';
import { createChart, IChartApi } from 'lightweight-charts';

export function TradingChart({ data }: { data: ChartData[] }) {
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<IChartApi | null>(null);

  useEffect(() => {
    if (!chartContainerRef.current) return;

    chartRef.current = createChart(chartContainerRef.current, {
      width: chartContainerRef.current.clientWidth,
      height: 400,
      layout: { background: { color: '#ffffff' } }
    });

    const lineSeries = chartRef.current.addLineSeries({
      color: '#2563eb',
      lineWidth: 2
    });
    
    lineSeries.setData(data);

    return () => {
      if (chartRef.current) {
        chartRef.current.remove();
      }
    };
  }, [data]);

  return <div ref={chartContainerRef} className="w-full h-96" />;
}
```

### Real-time Updates
- Use Socket.IO for live trade updates
- Implement connection status indicators
- Handle reconnection gracefully

Example WebSocket Hook:
```typescript
export function useWebSocket() {
  const dispatch = useAppDispatch();
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    const token = localStorage.getItem('token');
    if (!token) return;

    const socket = io(process.env.NEXT_PUBLIC_WS_URL!, {
      auth: { token }
    });

    socket.on('connect', () => setIsConnected(true));
    socket.on('disconnect', () => setIsConnected(false));
    
    socket.on('trade:created', (trade) => {
      dispatch(addTrade(trade));
    });

    socket.on('trade:updated', (trade) => {
      dispatch(updateTrade(trade));
    });

    return () => socket.disconnect();
  }, [dispatch]);

  return { isConnected };
}
```

## Performance Optimization

### Code Splitting
- Use dynamic imports for large components
- Implement route-based code splitting
- Lazy load below-the-fold content

```typescript
import dynamic from 'next/dynamic';

const TradingChart = dynamic(() => import('./TradingChart'), {
  loading: () => <div className="h-96 bg-gray-100 animate-pulse" />,
  ssr: false
});
```

### Image Optimization
- Always use Next.js Image component
- Provide appropriate sizes and priority
- Use modern image formats (WebP, AVIF)

```typescript
import Image from 'next/image';

<Image
  src={trade.screenshot}
  alt={`${trade.symbol} trade screenshot`}
  width={400}
  height={300}
  className="rounded-lg"
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
/>
```

### Memoization
- Use React.memo for expensive components
- Use useMemo for expensive calculations
- Use useCallback for event handlers passed to children

```typescript
const MemoizedTradeList = React.memo(function TradeList({ trades, onEdit }) {
  return (
    <div className="space-y-4">
      {trades.map(trade => (
        <TradeCard key={trade.id} trade={trade} onEdit={onEdit} />
      ))}
    </div>
  );
});
```

## Form Handling

### React Hook Form (when needed)
- Use for complex forms with validation
- Implement proper error handling
- Use controlled components sparingly

```typescript
import { useForm } from 'react-hook-form';

export function TradeForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<TradeFormData>();

  const onSubmit = async (data: TradeFormData) => {
    try {
      await dispatch(createTrade(data)).unwrap();
      // Handle success
    } catch (error) {
      // Handle error
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <input
        {...register('symbol', { required: 'Symbol is required' })}
        className="w-full p-2 border rounded-md"
        placeholder="Symbol (e.g., EURUSD)"
      />
      {errors.symbol && (
        <p className="text-red-600 text-sm">{errors.symbol.message}</p>
      )}
    </form>
  );
}
```

## Error Handling

### Error Boundaries
- Implement error boundaries for critical sections
- Provide meaningful error messages
- Include recovery actions

```typescript
'use client';
export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <html>
      <body>
        <div className="min-h-screen flex items-center justify-center">
          <div className="text-center">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">
              Something went wrong!
            </h2>
            <button
              onClick={reset}
              className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
            >
              Try again
            </button>
          </div>
        </div>
      </body>
    </html>
  );
}
```

## API Integration

### Service Layer
- Create dedicated API service functions
- Use axios with proper configuration
- Implement request/response interceptors

```typescript
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  timeout: 10000
});

api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export const tradesApi = {
  getTrades: (params: GetTradesParams) => api.get('/trades', { params }),
  createTrade: (data: CreateTradeData) => api.post('/trades', data),
  updateTrade: (id: string, data: UpdateTradeData) => api.put(`/trades/${id}`, data),
  deleteTrade: (id: string) => api.delete(`/trades/${id}`)
};
```

## SEO and Meta Tags
- Use Next.js metadata API
- Implement proper OpenGraph tags
- Include structured data for trading content

```typescript
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Trading Journal | TradeTaper',
  description: 'Professional trading journal with MT5 integration',
  openGraph: {
    title: 'TradeTaper - Professional Trading Journal',
    description: 'Track your trades with advanced analytics',
    images: ['/og-image.jpg']
  }
};
```

## Common Commands

```bash
# Development
npm run dev

# Building
npm run build
npm run start

# Type checking
npx tsc --noEmit

# Linting
npm run lint
```

## Error Prevention

### Don't:
- Use useEffect for derived state
- Forget to handle loading states
- Skip error boundaries
- Ignore accessibility (a11y)
- Bundle server-only code in client
- Forget to optimize images
- Skip proper TypeScript typing

### Do:
- Use Server Components by default
- Implement proper loading states
- Add error boundaries for critical sections
- Include ARIA attributes and semantic HTML
- Use dynamic imports for code splitting
- Optimize images with Next.js Image
- Type all props and state properly

## Trading UI Best Practices

### Color Coding
- Green for profitable/buy trades
- Red for losing/sell trades
- Gray for pending/neutral states
- Blue for informational elements

### Data Display
- Show prices with appropriate decimal places
- Format currencies consistently
- Display percentages with + or - signs
- Use tables for trade lists with sorting

### Real-time Indicators
- Show connection status clearly
- Use subtle animations for updates
- Indicate when data is stale
- Provide manual refresh options

When working on this frontend, prioritize user experience, performance, and real-time trading data accuracy. Always consider mobile users and implement responsive designs.